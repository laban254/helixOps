package output

import (
	"fmt"
	"os"
	"path/filepath"
	"time"

	"helixops/internal/config"
	"helixops/internal/models"
)

// MarkdownReporter generates Markdown incident reports
type MarkdownReporter struct {
	outputDir string
}

// NewMarkdownReporter creates a new Markdown reporter
func NewMarkdownReporter(outputDir string) *MarkdownReporter {
	// Ensure directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		fmt.Printf("Warning: failed to create output directory: %v\n", err)
	}
	return &MarkdownReporter{
		outputDir: outputDir,
	}
}

// Report generates a Markdown report for an analysis result
func (m *MarkdownReporter) Report(result *models.AnalysisResult) error {
	if m.outputDir == "" {
		return fmt.Errorf("output directory not configured")
	}

	filename := fmt.Sprintf("incident-%s-%s.md", result.ServiceName, result.ID[:8])
	filePath := filepath.Join(m.outputDir, filename)

	content := m.buildReport(result)

	if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write report: %w", err)
	}

	fmt.Printf("Report generated: %s\n", filePath)
	return nil
}

// buildReport creates the Markdown content
func (m *MarkdownReporter) buildReport(result *models.AnalysisResult) string {
	return fmt.Sprintf(`# Incident Report

## Overview

| Field | Value |
|-------|-------|
| **Service** | %s |
| **Alert** | %s |
| **Severity** | %s |
| **Started** | %s |
| **Analyzed** | %s |
| **Report ID** | %s |

## AI Analysis

### Root Cause
%s

### Confidence
%s

## Metrics

### Current
| Metric | Value |
|--------|-------|
| Latency P99 | %.2f ms |
| Error Rate | %.2f %% |
| Requests/sec | %.2f |

### Baseline
| Metric | Value |
|--------|-------|
| Latency | %.2f ms |
| Error Rate | %.2f %% |

## Recent Commits

%s

## Next Steps

%s

---
*Generated by HelixOps*
`,
		result.ServiceName,
		result.AlertName,
		result.Severity,
		result.AnalyzedAt.Add(-time.Hour).Format(time.RFC3339),
		result.AnalyzedAt.Format(time.RFC3339),
		result.ID,
		result.RootCause,
		result.Confidence,
		result.Metrics.LatencyP99,
		result.Metrics.ErrorRate*100,
		result.Metrics.RPS,
		result.Metrics.BaselineLatency,
		result.Metrics.BaselineErrorRate*100,
		m.formatCommits(result.Commits),
		m.formatNextSteps(result.NextSteps),
	)
}

// formatCommits formats commits for the report
func (m *MarkdownReporter) formatCommits(commits []models.CommitInfo) string {
	if len(commits) == 0 {
		return "No recent commits found."
	}

	result := "| SHA | Author | Message | Time |\n|------|--------|---------|------|\n"
	for _, c := range commits {
		timestamp := c.Timestamp.Format(time.RFC3339)
		result += fmt.Sprintf("| `%s` | %s | %s | %s |\n", c.SHA[:7], c.Author, truncate(c.Message, 50), timestamp)
	}
	return result
}

// formatNextSteps formats next steps for the report
func (m *MarkdownReporter) formatNextSteps(steps []string) string {
	if len(steps) == 0 {
		return "No specific next steps identified."
	}

	result := ""
	for i, step := range steps {
		result += fmt.Sprintf("%d. %s\n", i+1, step)
	}
	return result
}

// truncate truncates a string
func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen] + "..."
}

// MarkdownConfig creates a Markdown reporter from config
func NewMarkdownReporterFromConfig(cfg config.MarkdownOutputConfig) *MarkdownReporter {
	return NewMarkdownReporter(cfg.OutputDir)
}
